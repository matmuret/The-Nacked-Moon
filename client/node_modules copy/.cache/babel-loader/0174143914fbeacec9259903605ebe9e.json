{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useStateWithHistory = void 0;\n\nvar react_1 = require(\"react\");\n\nvar useFirstMountState_1 = require(\"./useFirstMountState\");\n\nvar resolveHookState_1 = require(\"./util/resolveHookState\");\n\nfunction useStateWithHistory(initialState, capacity, initialHistory) {\n  if (capacity === void 0) {\n    capacity = 10;\n  }\n\n  if (capacity < 1) {\n    throw new Error(\"Capacity has to be greater than 1, got '\" + capacity + \"'\");\n  }\n\n  var isFirstMount = useFirstMountState_1.useFirstMountState();\n\n  var _a = react_1.useState(initialState),\n      state = _a[0],\n      innerSetState = _a[1];\n\n  var history = react_1.useRef(initialHistory !== null && initialHistory !== void 0 ? initialHistory : []);\n  var historyPosition = react_1.useRef(0); // do the states manipulation only on first mount, no sense to load re-renders with useless calculations\n\n  if (isFirstMount) {\n    if (history.current.length) {\n      // if last element of history !== initial - push initial to history\n      if (history.current[history.current.length - 1] !== initialState) {\n        history.current.push(initialState);\n      } // if initial history bigger that capacity - crop the first elements out\n\n\n      if (history.current.length > capacity) {\n        history.current = history.current.slice(history.current.length - capacity);\n      }\n    } else {\n      // initiate the history with initial state\n      history.current.push(initialState);\n    }\n\n    historyPosition.current = history.current.length && history.current.length - 1;\n  }\n\n  var setState = react_1.useCallback(function (newState) {\n    innerSetState(function (currentState) {\n      newState = resolveHookState_1.resolveHookState(newState); // is state has changed\n\n      if (newState !== currentState) {\n        // if current position is not the last - pop element to the right\n        if (historyPosition.current < history.current.length - 1) {\n          history.current = history.current.slice(0, historyPosition.current + 1);\n        }\n\n        historyPosition.current = history.current.push(newState) - 1; // if capacity is reached - shift first elements\n\n        if (history.current.length > capacity) {\n          history.current = history.current.slice(history.current.length - capacity);\n        }\n      }\n\n      return newState;\n    });\n  }, [state, capacity]);\n  var historyState = react_1.useMemo(function () {\n    return {\n      history: history.current,\n      position: historyPosition.current,\n      capacity: capacity,\n      back: function back(amount) {\n        if (amount === void 0) {\n          amount = 1;\n        } // don't do anything if we already at the left border\n\n\n        if (!historyPosition.current) {\n          return;\n        }\n\n        innerSetState(function () {\n          historyPosition.current -= Math.min(amount, historyPosition.current);\n          return history.current[historyPosition.current];\n        });\n      },\n      forward: function forward(amount) {\n        if (amount === void 0) {\n          amount = 1;\n        } // don't do anything if we already at the right border\n\n\n        if (historyPosition.current === history.current.length - 1) {\n          return;\n        }\n\n        innerSetState(function () {\n          historyPosition.current = Math.min(historyPosition.current + amount, history.current.length - 1);\n          return history.current[historyPosition.current];\n        });\n      },\n      go: function go(position) {\n        if (position === historyPosition.current) {\n          return;\n        }\n\n        innerSetState(function () {\n          historyPosition.current = position < 0 ? Math.max(history.current.length + position, 0) : Math.min(history.current.length - 1, position);\n          return history.current[historyPosition.current];\n        });\n      }\n    };\n  }, [state]);\n  return [state, setState, historyState];\n}\n\nexports.useStateWithHistory = useStateWithHistory;","map":{"version":3,"sources":["/Users/filippo/Documents/DCI/myProjects/TheNakedMoon/Frontend/node_modules/react-use/lib/useStateWithHistory.js"],"names":["Object","defineProperty","exports","value","useStateWithHistory","react_1","require","useFirstMountState_1","resolveHookState_1","initialState","capacity","initialHistory","Error","isFirstMount","useFirstMountState","_a","useState","state","innerSetState","history","useRef","historyPosition","current","length","push","slice","setState","useCallback","newState","currentState","resolveHookState","historyState","useMemo","position","back","amount","Math","min","forward","go","max"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useStateWithHistory = void 0;\nvar react_1 = require(\"react\");\nvar useFirstMountState_1 = require(\"./useFirstMountState\");\nvar resolveHookState_1 = require(\"./util/resolveHookState\");\nfunction useStateWithHistory(initialState, capacity, initialHistory) {\n    if (capacity === void 0) { capacity = 10; }\n    if (capacity < 1) {\n        throw new Error(\"Capacity has to be greater than 1, got '\" + capacity + \"'\");\n    }\n    var isFirstMount = useFirstMountState_1.useFirstMountState();\n    var _a = react_1.useState(initialState), state = _a[0], innerSetState = _a[1];\n    var history = react_1.useRef((initialHistory !== null && initialHistory !== void 0 ? initialHistory : []));\n    var historyPosition = react_1.useRef(0);\n    // do the states manipulation only on first mount, no sense to load re-renders with useless calculations\n    if (isFirstMount) {\n        if (history.current.length) {\n            // if last element of history !== initial - push initial to history\n            if (history.current[history.current.length - 1] !== initialState) {\n                history.current.push(initialState);\n            }\n            // if initial history bigger that capacity - crop the first elements out\n            if (history.current.length > capacity) {\n                history.current = history.current.slice(history.current.length - capacity);\n            }\n        }\n        else {\n            // initiate the history with initial state\n            history.current.push(initialState);\n        }\n        historyPosition.current = history.current.length && history.current.length - 1;\n    }\n    var setState = react_1.useCallback(function (newState) {\n        innerSetState(function (currentState) {\n            newState = resolveHookState_1.resolveHookState(newState);\n            // is state has changed\n            if (newState !== currentState) {\n                // if current position is not the last - pop element to the right\n                if (historyPosition.current < history.current.length - 1) {\n                    history.current = history.current.slice(0, historyPosition.current + 1);\n                }\n                historyPosition.current = history.current.push(newState) - 1;\n                // if capacity is reached - shift first elements\n                if (history.current.length > capacity) {\n                    history.current = history.current.slice(history.current.length - capacity);\n                }\n            }\n            return newState;\n        });\n    }, [state, capacity]);\n    var historyState = react_1.useMemo(function () { return ({\n        history: history.current,\n        position: historyPosition.current,\n        capacity: capacity,\n        back: function (amount) {\n            if (amount === void 0) { amount = 1; }\n            // don't do anything if we already at the left border\n            if (!historyPosition.current) {\n                return;\n            }\n            innerSetState(function () {\n                historyPosition.current -= Math.min(amount, historyPosition.current);\n                return history.current[historyPosition.current];\n            });\n        },\n        forward: function (amount) {\n            if (amount === void 0) { amount = 1; }\n            // don't do anything if we already at the right border\n            if (historyPosition.current === history.current.length - 1) {\n                return;\n            }\n            innerSetState(function () {\n                historyPosition.current = Math.min(historyPosition.current + amount, history.current.length - 1);\n                return history.current[historyPosition.current];\n            });\n        },\n        go: function (position) {\n            if (position === historyPosition.current) {\n                return;\n            }\n            innerSetState(function () {\n                historyPosition.current =\n                    position < 0\n                        ? Math.max(history.current.length + position, 0)\n                        : Math.min(history.current.length - 1, position);\n                return history.current[historyPosition.current];\n            });\n        },\n    }); }, [state]);\n    return [state, setState, historyState];\n}\nexports.useStateWithHistory = useStateWithHistory;\n"]},"metadata":{},"sourceType":"script"}